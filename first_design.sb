# %% [markdown]
# Starboard - First Design Sprint

## Availibility of attractive cultural facilities in the destricts of Berlin

\
**This notebook is loaded directly from github:**

<https://github.com/Waschi97/DataViz/tree/main/first_design.sb>

There is no need for any browser-based installations.
# %%--- [markdown]
# properties:
#   locked: true
# ---%%
### Goal:

Cultural facilities are spread all over Berlin. With information about the amount of visitors each facility gets attractiveness can be defined for each of them. Now it might be desirable that each district can account for at least some attractive cultural facilities. With this information one could decide whether some destricts might be in need of some governmental support.

\
The goal of this starboard is to provide a visualization that gives insight to this question:

**Are attractive cultural facilities availible in each district of Berlin?**
# %% [markdown]
### Data:

The data for this project originated from [daten.berlin.de](https://daten.berlin.de) which is an online service that gives access to a vast load of different data sets and is provided by the Berlin Senate Department for Economics, Energy and Public Enterprises.

\
Here we needed two data sets in particular:

* positional data set: [https://daten.berlin.de/datensaetze/standorte-gef√∂rderter-kultureinrichtungen](https://daten.berlin.de/datensaetze/standorte-gef%C3%B6rderter-kultureinrichtungen)
* data set containg visitor information: <https://daten.berlin.de/datensaetze/besuchszahlen-%C3%B6ffentlich-gef%C3%B6rderten-berliner-kultureinrichtungen>

The second link actually gives access to two data sets containing visitor information; one for 2011/12 and one for 2013/14.

\
All data is provided in .XLS format (Microsoft Excel). As this format is really awkward to work with we transformed the tables into .CSV and subsequently into .JSON files manually. Afterwards we made them availible in our github repository and simply fetch them.
# %% [markdown]
### Preprocessing:

Before we can visualize the data we need to do some preprocessing.

\
First of all we strip the postcode from the adress of each facility and use it to order the facility into its district. As some postcodes appear in multiple different districts we needed to resolve these conflicts manually.

\
Secondly the visitor information is itemized by a lot of different features; paying vs. non-paying, female vs. male, children vs. adults. We decided to not include this itemization and simply use the overall number of visitors disregarding their properties. The only split that remains is the seperation by year.

\
Lastly we combined the two informations into a well suited datastructure ready for plotting.
# %% [javascript]
const url_11_12 = "https://raw.githubusercontent.com/Waschi97/DataViz/main/json_daten/besucherstatistik-2011_2012.json";
const url_13_14 = "https://raw.githubusercontent.com/Waschi97/DataViz/main/json_daten/besucherstatistik-2013_2014.json";
const url_names = "https://raw.githubusercontent.com/Waschi97/DataViz/main/json_daten/kultureinrichtungen_alle.json";
const url_postcodes = "https://raw.githubusercontent.com/Waschi97/DataViz/main/json_daten/BerlinPLZ.json";

var resp = await fetch(url_postcodes);
var zipcodes_json = await resp.json();

resp = await fetch(url_names);
var names_json = await resp.json();

resp = await fetch(url_11_12);
var stats_11_12_json = await resp.json();

resp = await fetch(url_13_14);
var stats_13_14_json = await resp.json();

// console.log(stats_13_14_json);
# %% [javascript]


function addr2plz(addr) {
  if(VERBOSE) {
    console.log("Addr:" + addr);
  }
  if(addr == null) {
    return null;
  }

  const trimmed = addr.replaceAll(/\s/g,'');
  const commaPos = trimmed.indexOf(",");
  if (commaPos == -1) {
    return null;
  }
  return parseInt(trimmed.substring(commaPos + 1, commaPos + 6));
}

function name2addr(name) {
  if(VERBOSE) {
  	console.log("Name:" + name)
  }
  if(name == null) {
    return null;
  }
  
  const objects = names_json.filter(obj => obj["Institution"] == name);
  
  if(objects.length < 1) {
    return null;
  }
  return objects[0]["Adresse"]; 
}

function plz2distr(plz) {
  if(VERBOSE) {
  console.log("PLZ:" + plz)
  }
  if(plz == null) {
    return null;
  }
  
  var objects = zipcodes_json.filter(obj => obj["PLZ"] == plz); 
  
  if(objects.length < 1) {
    return null;
  }
  return objects[0]["Stadtteil"];
}

// Returns district from insitition name
function name2distr(name) {
  return plz2distr(addr2plz(name2addr(name)));
}

// TODO:
//  - Can we do something about so many names of the 11_12_dataset 
//     not being matched in the names dataset?
function districtTransform() {

  var transformed = {};
  const datasets = [stats_11_12_json, stats_13_14_json];
  const years = [["2011", "2012"], ["2013", "2014"]];
  
  for(var k = 0; k < 2; k++)  {
    
    dataset = datasets[k];
    var year__0 = years[k][0];
    var year__1 = years[k][1];
    
    for(var i = 0; i < dataset.length ; i++) {
    
    	const obj = dataset[i];
    	const name = obj["Institutionsname"];
    
    	if(name == "") {
          continue;
    	}
    
		const distr = name2distr(name);    
    	if (distr == null) {
      	  continue;
    	}

    	if(!(distr in transformed)) {
      	  transformed[distr] = {};
    	}
    
        if(!(year__0 in transformed[distr])) {
          transformed[distr][year__0] = [];
        }

        if(!(year__1 in transformed[distr])) {
          transformed[distr][year__1] = [];
        }

        var obj_1 = {};
        var obj_2 = {};
        
        const keys__1 = Object.keys(obj).filter(key => key.includes("__1"));
    	var nonConstantKeys = [];
        
        for(var j = 0; j < keys__1.length; j++) {
          
          const keyShort = keys__1[j].substring(0,  keys__1[j].indexOf("__1"));
          
          nonConstantKeys.push(keyShort);
          nonConstantKeys.push(keys__1[j]);
          
          obj_1[keyShort] = obj[keyShort];
          obj_2[keyShort] = obj[keys__1[j]];
          
        }
    
        const constantKeys = Object.keys(obj).filter(key => !nonConstantKeys.includes(key));
        
        for(var j = 0; j < constantKeys.length; j++) {
          obj_1[constantKeys[j]] = obj[constantKeys[j]];
          obj_2[constantKeys[j]] = obj[constantKeys[j]];
        }
        
        transformed[distr][year__0].push(obj_1);
        transformed[distr][year__1].push(obj_2);
    
 	 }
  }
  return transformed;
}

VERBOSE = false
console.log(districtTransform());