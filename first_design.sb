# %% [markdown]
# Starboard - First Design Sprint

## Availability of attractive cultural facilities in the destricts of Berlin

\
**This notebook is loaded directly from github:**

<https://github.com/Waschi97/DataViz/tree/main/first_design.sb>

There is no need for any browser-based installations.
# %%--- [markdown]
# properties:
#   locked: true
# ---%%
### Goal:

Cultural facilities are spread all over Berlin. With information about the amount of visitors each facility gets attractiveness can be defined for each of them. Now it might be desirable that each district can account for at least some attractive cultural facilities. With this information one could decide whether some destricts might be in need of some governmental support.

\
The goal of this starboard is to provide a visualization that gives insight to this question:

**Are attractive cultural facilities availible in each district of Berlin?**
# %% [markdown]
### Data:

The data for this project originated from [daten.berlin.de](https://daten.berlin.de) which is an online service that gives access to a vast load of different data sets and is provided by the Berlin Senate Department for Economics, Energy and Public Enterprises.

\
Here we needed two data sets in particular:

* positional data set: [https://daten.berlin.de/datensaetze/standorte-geförderter-kultureinrichtungen](https://daten.berlin.de/datensaetze/standorte-gef%C3%B6rderter-kultureinrichtungen)
* data set containg visitor information: <https://daten.berlin.de/datensaetze/besuchszahlen-%C3%B6ffentlich-gef%C3%B6rderten-berliner-kultureinrichtungen>

The second link actually gives access to two data sets containing visitor information; one for 2011/12 and one for 2013/14.

\
All data is provided in .XLS format (Microsoft Excel). As this format is really awkward to work with we transformed the tables into .CSV and subsequently into .JSON files manually. Afterwards we made them availible in our github repository and simply fetch them.
# %% [markdown]
### Preprocessing:

Before we can visualize the data we need to do some preprocessing.

\
First of all we strip the postcode from the adress of each facility and use it to order the facility into its district. As some postcodes overlap multiple different districts. For these cases we opted to count the facility as being “in” all the found districts. This decision arose from the motivation that facilities with a postcode spaning multiple districts should be availible for residence of these districts and therefore be counted for all of them.

\
Secondly the visitor information is itemized by a lot of different features; paying vs. non-paying, female vs. male, children vs. adults. We decided to not include this itemization and simply use the overall number of visitors disregarding their properties. The only split that remains is the seperation by year.

\
Lastly we combined the two informations into a well suited datastructure ready for plotting.
# %%--- [javascript]
# properties:
#   run_on_load: true
#   top_hidden: true
# ---%%
const url_11_12 = "https://raw.githubusercontent.com/Waschi97/DataViz/main/json_daten/besucherstatistik-2011_2012.json";
const url_13_14 = "https://raw.githubusercontent.com/Waschi97/DataViz/main/json_daten/besucherstatistik-2013_2014.json";
const url_names = "https://raw.githubusercontent.com/Waschi97/DataViz/main/json_daten/kultureinrichtungen_alle.json";
const url_postcodes = "https://raw.githubusercontent.com/Waschi97/DataViz/main/json_daten/BerlinPLZ.json";

var resp = await fetch(url_postcodes);
var zipcodes_json = await resp.json();

resp = await fetch(url_names);
var names_json = await resp.json();

resp = await fetch(url_11_12);
var stats_11_12_json = await resp.json();

resp = await fetch(url_13_14);
var stats_13_14_json = await resp.json();

// console.log(stats_13_14_json);
# %%--- [javascript]
# properties:
#   run_on_load: true
#   top_hidden: true
# ---%%
function addr2plz(addr) {
    if (VERBOSE) {
        console.log("Addr:" + addr);
    }
    if (addr == null) {
        return null;
    }

    const trimmed = addr.replaceAll(/\s/g, '');
    const commaPos = trimmed.indexOf(",");
    if (commaPos == -1) {
        return null;
    }
    return parseInt(trimmed.substring(commaPos + 1, commaPos + 6));
}

function name2addr(name) {
    if (VERBOSE) {
        console.log("Name:" + name)
    }
    if (name == null) {
        return null;
    }

    const objects = names_json.filter(obj => obj["Institution"] == name);

    if (objects.length < 1) {
        return null;
    }
    return objects[0]["Adresse"];
}

function plz2distr(plz) {
    if (VERBOSE) {
        console.log("PLZ:" + plz)
    }
    if (plz == null) {
        return null;
    }

    var objects = zipcodes_json.filter(obj => obj["PLZ"] == plz);

    if (objects.length < 1) {
        return null;
    }

    if (objects.length > 1) {
        var unique = [];
        for (var u = 0; u < objects.length; u++) {
            if (!unique.filter(distr => distr == objects[u]["Stadtteil"]).length > 0) {
                unique.push(objects[u]["Stadtteil"]);
            }
        }
        return unique;
    }

    return [objects[0]["Stadtteil"]];
}

// Returns district from insitition name
function name2distr(name) {
    return plz2distr(addr2plz(name2addr(name)));
}

var missing = [];

// TODO:
//  - Can we do something about so many names of the 11_12_dataset 
//     not being matched in the names dataset?
function districtTransform() {

    var transformed = {};
    const datasets = [stats_11_12_json, stats_13_14_json];
    const years = [["2011", "2012"], ["2013", "2014"]];
  	
    for (var k = 0; k < 2; k++) {

        dataset = datasets[k];
        var year__0 = years[k][0];
        var year__1 = years[k][1];

        for (var i = 0; i < dataset.length; i++) {

            const obj = dataset[i];
            const name = obj["Institutionsname"];

            if (name == "") {
                continue;
            }

            const districts = name2distr(name);

            if (districts == null) {
                if(missing.filter(n => n == name).length == 0) {
          			missing.push(name);
          		}
                continue;
            }

            for (var u = 0; u < districts.length; u++) {
                const distr = districts[u];

                if (!(distr in transformed)) {
                    transformed[distr] = {};
                }

                if (!(year__0 in transformed[distr])) {
                    transformed[distr][year__0] = [];
                }

                if (!(year__1 in transformed[distr])) {
                    transformed[distr][year__1] = [];
                }

                var obj_1 = {};
                var obj_2 = {};

                const keys__1 = Object.keys(obj).filter(key => key.includes("__1"));
                var nonConstantKeys = [];

                for (var j = 0; j < keys__1.length; j++) {

                    const keyShort = keys__1[j].substring(0, keys__1[j].indexOf("__1"));

                    nonConstantKeys.push(keyShort);
                    nonConstantKeys.push(keys__1[j]);

                    obj_1[keyShort] = obj[keyShort];
                    obj_2[keyShort] = obj[keys__1[j]];

                }

                const constantKeys = Object.keys(obj).filter(key => !nonConstantKeys.includes(key));

                for (var j = 0; j < constantKeys.length; j++) {
                    obj_1[constantKeys[j]] = obj[constantKeys[j]];
                    obj_2[constantKeys[j]] = obj[constantKeys[j]];
                }

                transformed[distr][year__0].push(obj_1);
                transformed[distr][year__1].push(obj_2);

            }
        }
    }
    return transformed;
}

VERBOSE = false
console.log(districtTransform());
// console.log(missing)
# %% [markdown]
Please take note that for some institution names in the “besuchzahlen…”- dataset, the containing district could be determined programmatically (e.g. because the name could not be matched in the “standorte…”- dataset). For this prototype, these institutions were therefore excluded from our visualization.

In the following, you can see the names of these institutions as they are contained in the “besuchzahlen…”-dataset.
# %%--- [javascript]
# properties:
#   top_hidden: true
#   run_on_load: true
# ---%%
console.log(missing);

# %%--- [javascript]
# properties:
#   run_on_load: true
#   top_hidden: true
#   bottom_hidden: true
# ---%%
var data = districtTransform();

var districts = Object.keys(data);
var years = [2011,2012,2013,2014];

bins = [[0, 100000], [100000, 300000], [300000, 30000000]]

const CHART_COLORS = {
  red: 'rgb(255, 99, 132)',
  orange: 'rgb(255, 159, 64)',
  yellow: 'rgb(255, 205, 86)',
  green: 'rgb(75, 192, 192)',
  blue: 'rgb(54, 162, 235)',
  purple: 'rgb(153, 102, 255)',
  grey: 'rgb(201, 203, 207)'
};

data_all = {}
years.forEach(function (year){
  // init bin documentation
  var district_bins = [];

  //bins.forEach((bin) => {
  //  district_bins.push(0);
  //});

  // iterate through bins
  bins.forEach((bin, index) => {
	var bin_values = [];
    
    districts.forEach((district) => {

      var count = 0;
      // go through the attractions
      data[district][year].forEach((attraction) => {
        //console.log(attraction['Besuche_insgesamt'])
        var besuche = 0;
        if (typeof(attraction['Besuche_insgesamt']) == 'number') {
          besuche = attraction['Besuche_insgesamt'];
        }
        else {
        	besuche = parseInt(attraction['Besuche_insgesamt'].replace(',', ''));
        }
        if (besuche >= bin[0] && besuche < bin[1]) {
          count += 1;
        }
      });
      bin_values.push(count);
	});
    
    district_bins.push(bin_values);
    
  });

  // create dataset
  var dataset = {};
  dataset['labels'] = districts;
  dataset['datasets'] = []
  district_bins.forEach((bin, index) => {
    var label = '';
    if (index == 0) {
      label = '< ' + bins[index][1] + ' Besucher';
    }
    else {
      if (index == (district_bins.length - 1)) {
        label = '> ' + bins[index][0] + ' Besucher';
      }
      else {
        label = bins[index][0] + ' - ' + bins[index][1] + ' Besucher';
      }
    }
    var bin_object = {
      data: bin,
      label: label,
      backgroundColor: Object.values(CHART_COLORS)[index],
    }
    dataset['datasets'].push(bin_object);
  });

  // add total bin
  var total_bin = [];
  for ( let i = 0; i < districts.length; i++) {
    var total = 0;
    district_bins.forEach((bin) => {
      total += bin[i];
    });

    total_bin.push(total);
  }

  dataset['datasets'].push({
    data: total_bin,
    label: 'Total',
    backgroundColor: CHART_COLORS['grey'],
  });
  
  // add to data_all
  data_all[year] = dataset;
});

data_all
# %%--- [javascript]
# properties:
#   run_on_load: true
#   top_hidden: true
# ---%%
// Loading Chart.js from a CDN.
await import("https://cdn.jsdelivr.net/npm/chart.js@3.9.1/dist/chart.min.js");
await import("https://ajax.googleapis.com/ajax/libs/jquery/2.1.1/jquery.min.js");


// A simple bar chart using Chart.js
//const canvas = 
const canvas = document.createElement("canvas");
const myChart = new Chart(canvas.getContext("2d"),
    {
        type: "bar",
        data: data_all[2011],
      	options: {
          indexAxis: 'y',
          elements: {
            bar: {
              borderWidth: 2,
            }
          },
          responsive: true,
          plugins: {
            legend: {
              position: 'right',
            }
          }
        }
    },
);

function btn_11 () {
  myChart.data = data_all[2011];
  myChart.update();
}

const button_2011 = document.createElement('button');
button_2011.appendChild(document.createTextNode('2011'));
button_2011.setAttribute('id', 'btn_2011');
button_2011.setAttribute('onclick', 'btn_11()');
button_2011.onclick = btn_11();
const button_2012 = document.createElement('button');
button_2012.appendChild(document.createTextNode('2012'));
button_2012.setAttribute('id', 'btn_2012');
button_2011.onclick = () => {myChart.data = data_all[2011]; myChart.update();};
const button_2013 = document.createElement('button');
button_2013.appendChild(document.createTextNode('2013'));
button_2013.setAttribute('id', 'btn_2013');
const button_2014 = document.createElement('button');
button_2011.onclick = () => {myChart.data = data_all[2011]; myChart.update();};
button_2014.appendChild(document.createTextNode('2014'));
button_2014.setAttribute('id', 'btn_2014');
button_2011.onclick = () => {myChart.data = data_all[2011]; myChart.update();};



//document.appendChild()
var div = document.createElement('div');
div.appendChild(canvas);
div.appendChild(button_2011);
div.appendChild(button_2012);
div.appendChild(button_2013);
div.appendChild(button_2014);





console.log(canvas);
console.log(button_2011);
console.log(div);
canvas
# %% [javascript]
// A simple bar chart using Chart.js
//const canvas = 
const canvas = document.createElement("canvas");
const myChart = new Chart(canvas.getContext("2d"),
    {
        type: "bar",
        data: data_all[2012],
      	options: {
          indexAxis: 'y',
          elements: {
            bar: {
              borderWidth: 2,
            }
          },
          responsive: true,
          plugins: {
            legend: {
              position: 'right',
            }
          }
        }
    },
);

canvas
# %%--- [javascript]
# properties:
#   run_on_load: true
#   top_hidden: true
# ---%%
// A simple bar chart using Chart.js
//const canvas = 
const canvas = document.createElement("canvas");
const myChart = new Chart(canvas.getContext("2d"),
    {
        type: "bar",
        data: data_all[2013],
      	options: {
          indexAxis: 'y',
          elements: {
            bar: {
              borderWidth: 2,
            }
          },
          responsive: true,
          plugins: {
            legend: {
              position: 'right',
            }
          }
        }
    },
);

canvas
# %%--- [javascript]
# properties:
#   run_on_load: true
#   top_hidden: true
# ---%%
// A simple bar chart using Chart.js
//const canvas = 
const canvas = document.createElement("canvas");
const myChart = new Chart(canvas.getContext("2d"),
    {
        type: "bar",
        data: data_all[2014],
      	options: {
          indexAxis: 'y',
          elements: {
            bar: {
              borderWidth: 2,
            }
          },
          responsive: true,
          plugins: {
            legend: {
              position: 'right',
            }
          }
        }
    },
);

canvas
